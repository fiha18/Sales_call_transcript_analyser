import os
import sys
import time
import utils
import prompts.youtube_summarizer_prompt as summarizer_prompt
import summarizer_helper
import llm_strategy.openai as openai

period_timer = None
start_execution_time = time.time()

def merge_chunk_summaries(chunk_response_list):
    """
    The `merge_chunk_summaries(chunk_response_list, summary_format="paragraph", word_limit=1000)` function consolidates summaries from multiple chunks into a cohesive summary.

    Parameters:
    - `chunk_response_list` (list): A list of summaries generated from different chunks of the transcript.
    - `summary_format` (str, optional): The format for the summary output (default is "paragraph"). Other options may include "bullet points" or "concise."
    - `word_limit` (int, optional): The maximum number of words for the final summary (default is 1000).

    Returns:
    - str: The cohesive summary generated by the OpenAI API based on the provided summaries and specified format.
    """
    system_message = summarizer_prompt.get_mindmap_merge_system_message(chunk_response_list)
    prompt_message = "Generate a detailed MindMap summary of the YouTube video content from the chunk summaries provided."
    final_response = openai.call_openai_api(system_message,prompt_message)
    return final_response

def generate_transcript_summary_list(file_path):
    """
    Creates a summary for a given file using the OpenAI GPT 4 API.

    Parameters:
    file_path (str): The path of the file.
    summary_format (str) : summary format should be paragraph, bullet_point or concise.

    Returns:
    str: The summary.
    """
    with open(file_path, "r") as f:
        print(f"Reading {os.path.basename(file_path)}")
        transcript = f.read()

    # Preprocess the transcript
    # transcript = summarizer_helper.preprocess_text(transcript)
    chunks = summarizer_helper.split_text(transcript)
    summary_list = []
    for chunk in enumerate(chunks, start=1):
        system_message = summarizer_prompt.get_mindmap_summarizer_system_message()
        prompt_message = summarizer_prompt.get_mindmap_summarizer_user_prompt(chunk,summary_list)
        # Generic openai api function which accepts system message and user prompt
        summary = openai.call_openai_api(system_message,prompt_message)
        summary_list.append(summary)
    return summary_list

def save_summary_file(file_path,summary):
    """
    This function saves a summary file to folder_path based on the provided final_response_content.

    Parameters:
        summary (str) : The text content to be written to the transcript file.
        file_path (str): The directory path where the transcript file will be saved.
    Returns:
        None
    """
    # Write the content to the transcript file
    with open(file_path, 'w') as file:
        file.write(summary)

def perform_call_transcript_summary_generation():
    """
    The `perform_call_transcript_summary_generation()` function generates a summary for a specified call transcript.
    - It retrieves the input file name and desired summary format (e.g., paragraph, bullet points) from command line arguments.
    - It checks if the transcript file exists and reads its contents.
    - The function calls `generate_transcript_summary_list()` to create a summary list based on the transcript and specified format.
    - It creates a directory for saving the summary if it does not already exist.
    - The summary is saved to a specified file format in the `generated_summaries` folder.
    - It handles various exceptions during file operations and prints the generated summary.
    """
    transcript_folder = "youtube_transcripts"
    command_line_args = sys.argv
    input_file_name = command_line_args[1]
    if not input_file_name:
        print(f"Input file {input_file_name} does not exists, skipping.")
        return 
    # either paragraph , bullet_points, concise
    # summary_format = command_line_args[2] if len(command_line_args) > 2  else "paragraph"
    # word_limit = command_line_args[3] if len(command_line_args) > 3 else 1000
    transcript_file_path = os.path.join(transcript_folder, input_file_name)
    if not os.path.exists(transcript_file_path):
        print(f"file {os.path.basename(transcript_file_path)} does not exists.")
        return 
    # summary_format paragraph, bullet points, concise
    summary_list = generate_transcript_summary_list(transcript_file_path)
    # folder path to save summary 
    folder_path="youtube_summaries"
    # Create the folder if it doesn't exist
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
    file_name = input_file_name.replace(".txt","_summary_list.txt")
    final_summary_file_name = input_file_name.replace(".txt","_summary.txt")
    file_path = os.path.join(folder_path, file_name)
    final_summary_file_path = os.path.join(folder_path, final_summary_file_name)
    if os.path.exists(file_name):
        print(f"Output file {os.path.basename(file_path)} already exists, skipping.")
        return
    if os.path.exists(final_summary_file_path):
        print(f"Output file {os.path.basename(final_summary_file_path)} already exists, skipping.")
        return
    # Creating final response 
    summary = merge_chunk_summaries(summary_list)  
    if summary_list is not None:
        try:
            # Saving only summary list as str , this can optimise query_handler
            print(f"Summary generated successfully and saved to folder: {folder_path}\nFilename: {file_name}")
            save_summary_file(file_path,"".join(summary_list))
            save_summary_file(final_summary_file_path,"".join(summary))
        except PermissionError:
            print(f"No permission to write file: {file_path}")
        except FileExistsError:
            print(f"File already exists: {file_path}")
        except Exception as e:
            print(f"An error occurred while writing the file: {file_path}. Error: {e}")
    print(summary)

perform_call_transcript_summary_generation() 
# summary_format - paragraph format ,bullet points or concise
#print(completion_usage)
end_execution_time = time.time()
total_time = float(end_execution_time - start_execution_time)
print(f"Total time taken: {total_time:.4f} seconds")
